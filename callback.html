<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Spotify OAuth Callback (PKCE)</title>
  </head>
  <body>
    <h3>Spotify Auth Callback</h3>
    <div id="status">Processing...</div>

    <script>
      /**
       * Exchange the authorization code for access + refresh tokens
       */
      async function exchangeCodeForToken(code, codeVerifier) {
        // Build the request body
        const clientId = 'YOUR_SPOTIFY_CLIENT_ID' // No secret needed for PKCE
        const redirectUri = 'https://<your-username>.github.io/my-spotify-callback/callback.html'
        // Must match EXACTLY the redirect URI in your Spotify app settings

        const body = new URLSearchParams()
        body.append('grant_type', 'authorization_code')
        body.append('code', code)
        body.append('redirect_uri', redirectUri)
        body.append('client_id', clientId)
        body.append('code_verifier', codeVerifier)

        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: body.toString()
        })

        if (!response.ok) {
          const errorText = await response.text()
          throw new Error('Token request failed: ' + errorText)
        }

        return await response.json() // { access_token, refresh_token, expires_in, token_type, scope }
      }

      async function main() {
        const statusDiv = document.getElementById('status')

        // Parse ?code and ?error from the URL
        const urlParams = new URLSearchParams(window.location.search)
        const code = urlParams.get('code')
        const error = urlParams.get('error')

        if (error) {
          statusDiv.textContent = `Authorization error: ${error}`
          return
        } else if (!code) {
          statusDiv.textContent = 'No code found in the URL. Please try logging in again.'
          return
        }

        // Retrieve the codeVerifier that we previously saved in chrome.storage (or localStorage).
        // Because callback.html is on another domain, we can't directly access chrome.storage.
        // So for PKCE in a purely client-side approach, you might have used localStorage on the same domain.
        // Or you do a server-based approach with sessions.
        //
        // For this minimal example, we'll assume the codeVerifier is NOT available unless we
        // added codeVerifier to localStorage on the same domain. (In real usage, you'd do more.)
        //
        // Another approach is: the extension opened a popup => we no longer have direct localStorage from the extension domain.
        //
        // If you can store the codeVerifier in localStorage *on the same domain*, do:
        //    const codeVerifier = localStorage.getItem("spotify_code_verifier");
        //
        // But for a purely cross-origin scenario, we do not have a direct way to read extension's localStorage.
        //
        // => Instead, let's show how you might do a purely client-side approach if you stored codeVerifier
        // in this same domain's localStorage. (This is just a simplified example.)
        const codeVerifier = localStorage.getItem('spotify_code_verifier')
        if (!codeVerifier) {
          statusDiv.textContent = 'No code verifier found in localStorage. PKCE cannot proceed.'
          return
        }

        // Now exchange the code + codeVerifier for tokens
        try {
          const tokenData = await exchangeCodeForToken(code, codeVerifier)
          statusDiv.textContent = `Access Token: ${tokenData.access_token}\n\nRefresh Token: ${tokenData.refresh_token}\n\nExpires In: ${tokenData.expires_in} seconds`

          // If the extension opened this page in a popup, we can pass the tokens back via postMessage
          if (window.opener) {
            window.opener.postMessage(
              {
                type: 'SPOTIFY_TOKEN',
                data: {
                  access_token: tokenData.access_token,
                  refresh_token: tokenData.refresh_token,
                  expires_in: tokenData.expires_in
                }
              },
              '*'
            )
          }

          // Optionally close the popup after a short delay
          // setTimeout(() => window.close(), 2000);
        } catch (err) {
          statusDiv.textContent = `Error exchanging code: ${err.message}`
        }
      }

      main()
    </script>
  </body>
</html>
